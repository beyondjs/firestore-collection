/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from 'firebase-admin/firestore';
import * as __beyond_dep_ns_1 from '@beyond-js/firestore-collection/response';
import * as __beyond_dep_ns_2 from '@beyond-js/firestore-collection/errors';
// batch.ts
declare namespace ns_0 {
  import WriteBatch = __beyond_dep_ns_0.WriteBatch;
  import Collection = ns_1.Collection;
  export class CollectionBatch<DataType> {
    #private;
    constructor(collection: Collection<DataType>);
    create(params: {
      id?: string;
      parents?: Record<string, string>;
      batch: WriteBatch;
      data: DataType;
    }): void;
    set(params: {
      id?: string;
      parents?: Record<string, string>;
      batch: WriteBatch;
      data: DataType;
    }): void;
  }
}


// collection.ts
declare namespace ns_1 {
  import CollectionReference = __beyond_dep_ns_0.CollectionReference;
  import DocumentReference = __beyond_dep_ns_0.DocumentReference;
  import DocumentSnapshot = __beyond_dep_ns_0.DocumentSnapshot;
  import Transaction = __beyond_dep_ns_0.Transaction;
  import PartialWithFieldValue = __beyond_dep_ns_0.PartialWithFieldValue;
  import Response = __beyond_dep_ns_1.Response;
  import CollectionBatch = ns_0.CollectionBatch;
  import FirestoreErrorManager = __beyond_dep_ns_2.FirestoreErrorManager;
  export interface ICollectionDataResponse<DataType> {
    doc?: DocumentReference<DataType>;
    snapshot?: DocumentSnapshot<DataType>;
    exists?: boolean;
    data?: DataType;
    error?: FirestoreErrorManager;
  }
  export type CollectionResponseType<DataType> = Response<ICollectionDataResponse<DataType>>;
  export type CollectionDatasetResponseType<DataType> = Response<ICollectionDataResponse<DataType>>[];
  interface IDataParams {
    id: string;
    parents?: Record<string, string>;
    transaction?: Transaction;
  }
  interface IDatasetParams {
    records: {
      id: string;
      parents?: Record<string, string>;
    }[];
    transaction?: Transaction;
  }
  /**
   * Generic class to handle Firestore collections and subcollections
   */
  export class Collection<DataType> {
    #private;
    get name(): string;
    get batch(): CollectionBatch<DataType>;
    get parent(): Collection<any>;
    constructor(name: string, parent?: Collection<any>);
    /**
     * 	Method to get a CollectionReference, optionally in the context of a parent
     * @param params
     * @returns
     */
    col(params?: {
      parents?: Record<string, string>;
    }): CollectionReference<DataType>;
    doc(params: {
      id: string;
      parents?: Record<string, string>;
    }): DocumentReference<DataType>;
    snapshot(params: {
      id: string;
      parents?: Record<string, string>;
      transaction?: Transaction;
    }): Promise<Response<{
      doc?: DocumentReference<DataType>;
      snapshot?: DocumentSnapshot<DataType>;
    }>>;
    /**
     * Process a single data document
     *
     * @param params
     * @returns
     */
    data(params: IDataParams): Promise<CollectionResponseType<DataType>>;
    dataset(params: IDatasetParams): Promise<CollectionDatasetResponseType<DataType>>;
    set(params: {
      id?: string;
      parents?: Record<string, string>;
      data: DataType;
      transaction?: Transaction;
    }): Promise<Response<{
      stored: boolean;
    }>>;
    merge(params: {
      id?: string;
      parents?: Record<string, string>;
      data: PartialWithFieldValue<DataType>;
      transaction?: Transaction;
    }): Promise<Response<{
      stored: boolean;
    }>>;
    delete(params: {
      id: string;
      parents?: Record<string, string>;
      transaction?: Transaction;
    }): Promise<Response<{
      deleted: boolean;
    }>>;
  }
  export class SubCollection<DataType> extends Collection<DataType> {
    constructor(name: string, parent: Collection<any>);
    col(params: {
      parents: Record<string, string>;
    }): CollectionReference<DataType>;
    doc(params: {
      id: string;
      parents: Record<string, string>;
      transaction?: Transaction;
    }): DocumentReference<DataType>;
    snapshot(params: {
      id: string;
      parents: Record<string, string>;
      transaction?: Transaction;
    }): Promise<Response<{
      doc?: DocumentReference<DataType>;
      snapshot?: DocumentSnapshot<DataType>;
    }>>;
    data(params: {
      id: string;
      parents: Record<string, string>;
      transaction?: Transaction;
    }): Promise<CollectionResponseType<DataType>>;
    delete(params: {
      id: string;
      parents: Record<string, string>;
      transaction?: Transaction;
    }): Promise<Response<{
      deleted: boolean;
    }>>;
  }
  export {};
}


export import ICollectionDataResponse = ns_1.ICollectionDataResponse;
export import CollectionResponseType = ns_1.CollectionResponseType;
export import CollectionDatasetResponseType = ns_1.CollectionDatasetResponseType;
export import Collection = ns_1.Collection;
export import SubCollection = ns_1.SubCollection;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };